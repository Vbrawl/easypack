#include "file_sections.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include <unistd.h>
#include <errno.h>
#include <sys/stat.h>
#include <string.h>


char* getExecutableName() {
  // Try to allocate enough space
  size_t BUF_SIZE = 0;
  ssize_t lnksize = 0;
  char *name = NULL,
  *name_bak = NULL;

  do {
    // Update buffer size
    BUF_SIZE += sizeof(char) * MAX_FILENAME_SIZE;

    // Reallocate buffer
    name = realloc(name, BUF_SIZE);
    if(name == NULL) {
      // in failure clear everything
      perror("getExecutableName()");
      free(name_bak);
      return NULL;
    }
    // Update name_bak which is used only for clearing
    // the buffer in case of failure
    name_bak = name;

    // Read link name
    lnksize = readlink("/proc/self/exe", name, BUF_SIZE);
    if(lnksize == -1) {
      perror("getExecutableName()");
      free(name);
      return NULL;
    }

    // readlink doesn't add a NULL-byte
    name[lnksize] = '\0';
  } while(lnksize == BUF_SIZE);

  // finally return the executable name
  return name;
}

uint32_t getExecutableSize() {
  int err = 0;
  struct stat info;
  uint32_t embedded_size = 0;
  char* exe_name = getExecutableName();
  if(exe_name == NULL) {
    return 0;
  }

  // Get file size
  err = stat(exe_name, &info);
  if(err == -1) {
    perror("getExecutableSize()");
    free(exe_name);
    return 0;
  }

  // Get embedded size
  embedded_size = getEmbeddedDataSize(exe_name);

  // clean up
  free(exe_name);
  return info.st_size - embedded_size - sizeof(embedded_size);
}

uint32_t getEmbeddedDataSize(char* exe_name) {
  uint32_t results = 0;
  FILE *f = NULL;
  size_t rbytes = 0;
  bool exe_name_autogenerated = false;

  // If exe_name is not set by the caller we try
  // to automatically resolve it.
  if(exe_name == NULL) {
    exe_name_autogenerated = true;
    exe_name = getExecutableName();
    if(exe_name == NULL) return 0;
  }

  // Open file
  f = fopen(exe_name, "rb");
  if(f == NULL) {
    perror("getEmbeddedDataSize()");
    if(exe_name_autogenerated) free(exe_name);
    return 0;
  }

  // Read last 4 bytes
  fseek(f, -sizeof(uint32_t), SEEK_END);
  rbytes = fread(&results, sizeof(uint32_t), 1, f);
  if(rbytes != 1) {
    printf("getEmbeddedDataSize(): Couldn't read embedded size, only %ld bytes read!\n", rbytes);
    if(exe_name_autogenerated) free(exe_name);
    return 0;
  }

  // Clean up
  fclose(f);
  if(exe_name_autogenerated) free(exe_name);
  return results;
}

char* getEmbeddedData(char* exe_name) {
  FILE *f = NULL;
  char* data = NULL;
  size_t rbytes = 0;

  bool exe_name_autogenerated = false;
  if(exe_name == NULL) {
    exe_name_autogenerated = true;
    exe_name = getExecutableName();
    if(exe_name == NULL) return NULL;
  }

  uint32_t data_size = getEmbeddedDataSize(exe_name);
  if(data_size == 0) {
    if(exe_name_autogenerated) free(exe_name);
    return NULL;
  }

  data = malloc(data_size + 1);
  if(data == NULL) {
    perror("getEmbeddedData()");
    if(exe_name_autogenerated) free(exe_name);
    return NULL;
  }

  f = fopen(exe_name, "rb");
  if(f == NULL) {
    perror("getEmbeddedData()");
    if(exe_name_autogenerated) free(exe_name);
    free(data);
    return NULL;
  }

  fseek(f, -(data_size + sizeof(uint32_t)), SEEK_END);
  rbytes = fread(data, sizeof(char), data_size, f);
  if(rbytes != data_size) {
    printf("getEmbeddedData(): Couldn't read embedded data, %ld/%d bytes read!\n", rbytes, data_size);
    if(exe_name_autogenerated) free(exe_name);
    free(data);
    return NULL;
  }
  data[rbytes] = '\0';

  fclose(f);
  if(exe_name_autogenerated) free(exe_name);
  return data;
}


void setEmbeddedData(char* exe_name, char* new_exe_name, char* data, uint32_t dsize) {
  FILE *f = NULL;
  size_t wbytes = 0, rbytes = 0;

  uint32_t esize = getExecutableSize();

  uint32_t final_size = esize + dsize + sizeof(uint32_t);
  char* final_data = malloc(final_size);

  // Read exe
  f = fopen(exe_name, "r");
  rbytes = fread(final_data, sizeof(char), esize, f);
  fclose(f);
  if(rbytes != esize) {
    printf("setEmbeddedData(): Couldn't read embedded data, %ld/%d bytes read!\n", rbytes, esize);
    free(final_data);
    return;
  }

  // Prepare contents
  memcpy(final_data + esize, data, dsize);
  memcpy(final_data + esize + dsize, &dsize, sizeof(dsize));

  // Write new exe
  f = fopen(new_exe_name, "w");
  wbytes = fwrite(final_data, sizeof(char), final_size, f);
  fclose(f);
  free(final_data);
  if(wbytes != final_size) {
    printf("setEmbeddedData(): Couldn't rewrite the exe file, %ld/%d bytes written!\n", wbytes, final_size);
    return;
  }
}
